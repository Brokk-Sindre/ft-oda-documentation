<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>JavaScript Fetch Client - Test</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">Test</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#javascript-fetch-client" class="nav-link">JavaScript Fetch Client</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#complete-client-implementation" class="nav-link">Complete Client Implementation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#key-features" class="nav-link">Key Features</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#installation-setup" class="nav-link">Installation &amp; Setup</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="javascript-fetch-client">JavaScript Fetch Client</h1>
<p>Complete, production-ready JavaScript client for the Danish Parliament API using modern fetch API.</p>
<h2 id="complete-client-implementation">Complete Client Implementation</h2>
<pre><code class="language-javascript">/**
 * Production-ready Danish Parliament API Client
 * 
 * Features:
 * - Modern fetch API with async/await
 * - Comprehensive error handling
 * - Automatic retry with exponential backoff
 * - Rate limiting and request throttling
 * - Memory-efficient pagination
 * - Browser and Node.js compatible
 */

// Polyfill for Node.js &lt; 18 (uncomment if needed)
// import fetch from 'node-fetch';

class DanishParliamentAPI {
  /**
   * Initialize the API client
   * 
   * @param {Object} options - Configuration options
   * @param {number} options.timeout - Request timeout in milliseconds (default: 30000)
   * @param {number} options.retryAttempts - Number of retry attempts (default: 3)
   * @param {number} options.requestDelay - Minimum delay between requests in ms (default: 100)
   */
  constructor(options = {}) {
    this.baseUrl = 'https://oda.ft.dk/api/';
    this.timeout = options.timeout || 30000;
    this.retryAttempts = options.retryAttempts || 3;
    this.requestDelay = options.requestDelay || 100;
    this.lastRequestTime = 0;
  }

  /**
   * Enforce rate limiting between requests
   */
  async _rateLimit() {
    const elapsed = Date.now() - this.lastRequestTime;
    if (elapsed &lt; this.requestDelay) {
      await this._sleep(this.requestDelay - elapsed);
    }
    this.lastRequestTime = Date.now();
  }

  /**
   * Sleep for specified milliseconds
   */
  _sleep(ms) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
  }

  /**
   * Build properly encoded URL with OData parameters
   * 
   * @param {string} entity - Entity name (e.g., 'Sag', 'Aktør')
   * @param {Object} params - OData parameters
   * @returns {string} Complete URL with encoded parameters
   */
  _buildUrl(entity, params = {}) {
    const url = `${this.baseUrl}${entity}`;

    if (Object.keys(params).length === 0) {
      return url;
    }

    const queryParts = [];
    for (const [key, value] of Object.entries(params)) {
      if (value !== null &amp;&amp; value !== undefined) {
        // Ensure $ parameters are properly encoded
        const encodedKey = key.startsWith('$') ? 
          encodeURIComponent(key) : key;
        const encodedValue = encodeURIComponent(value);
        queryParts.push(`${encodedKey}=${encodedValue}`);
      }
    }

    return `${url}?${queryParts.join('&amp;')}`;
  }

  /**
   * Make HTTP request with retry logic and error handling
   * 
   * @param {string} url - URL to request
   * @param {number} maxRetries - Override default retry attempts
   * @returns {Promise&lt;Object&gt;} Parsed JSON response
   */
  async _makeRequest(url, maxRetries = this.retryAttempts) {
    await this._rateLimit();

    for (let attempt = 0; attempt &lt; maxRetries; attempt++) {
      try {
        // Create AbortController for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() =&gt; controller.abort(), this.timeout);

        const response = await fetch(url, {
          signal: controller.signal,
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'DanishParliamentAPI-JS/1.0'
          }
        });

        clearTimeout(timeoutId);

        // Handle HTTP status codes
        if (response.ok) {
          return await response.json();
        }

        switch (response.status) {
          case 400:
            throw new APIError(
              `Invalid query parameters. Check $expand and $filter syntax. URL: ${url}`,
              'INVALID_QUERY'
            );

          case 404:
            if (url.includes('/api/') &amp;&amp; url.split('/').length === 5) {
              throw new EntityNotFoundError(`Entity not found: ${url.split('/').pop()}`);
            } else {
              throw new RecordNotFoundError(`Record not found: ${url}`);
            }

          case 501:
            throw new UnsupportedOperationError(
              'Write operations are not supported by this API'
            );

          default:
            throw new APIError(`HTTP ${response.status}: ${response.statusText}`);
        }

      } catch (error) {
        // Handle AbortError (timeout)
        if (error.name === 'AbortError') {
          if (attempt &lt; maxRetries - 1) {
            const waitTime = Math.pow(2, attempt) * 1000; // Exponential backoff
            console.warn(`Request timeout, retrying in ${waitTime}ms... (attempt ${attempt + 1}/${maxRetries})`);
            await this._sleep(waitTime);
            continue;
          }
          throw new NetworkError(`Request timed out after ${this.timeout}ms`);
        }

        // Handle network errors
        if (error.name === 'TypeError' &amp;&amp; error.message.includes('fetch')) {
          if (attempt &lt; maxRetries - 1) {
            const waitTime = Math.pow(2, attempt) * 1000;
            console.warn(`Network error, retrying in ${waitTime}ms... (attempt ${attempt + 1}/${maxRetries})`);
            await this._sleep(waitTime);
            continue;
          }
          throw new NetworkError(`Network error: ${error.message}`);
        }

        // Re-throw API errors without retry
        if (error instanceof APIError) {
          throw error;
        }

        // Unknown errors
        throw new NetworkError(`Request failed: ${error.message}`);
      }
    }
  }

  /**
   * Get parliamentary cases (Sag) with optional filtering and expansion
   * 
   * @param {Object} options - Query options
   * @param {number} options.top - Number of records to return (max 100)
   * @param {number} options.skip - Number of records to skip for pagination
   * @param {string} options.filter - OData filter expression
   * @param {string} options.expand - Related entities to include
   * @param {string} options.select - Specific fields to return
   * @param {string} options.orderby - Sort order
   * @returns {Promise&lt;Object&gt;} API response with case data
   * 
   * @example
   * // Get recent climate legislation
   * const cases = await api.getCases({
   *   filter: &quot;substringof('klima', titel)&quot;,
   *   expand: &quot;Sagskategori&quot;,
   *   top: 50
   * });
   */
  async getCases(options = {}) {
    const { top = 100, skip = 0, filter, expand, select, orderby } = options;

    const params = {
      '$top': Math.min(top, 100), // Enforce 100 record limit
      '$skip': skip
    };

    if (filter) params['$filter'] = filter;
    if (expand) params['$expand'] = expand;
    if (select) params['$select'] = select;
    if (orderby) params['$orderby'] = orderby;

    const url = this._buildUrl('Sag', params);
    return await this._makeRequest(url);
  }

  /**
   * Get parliamentary actors (Aktør) - politicians, committees, ministries
   * 
   * @param {Object} options - Query options
   * @returns {Promise&lt;Object&gt;} API response with actor data
   * 
   * @example
   * // Find all politicians with 'Jensen' in name
   * const actors = await api.getActors({
   *   filter: &quot;substringof('Jensen', navn)&quot;
   * });
   */
  async getActors(options = {}) {
    const { top = 100, skip = 0, filter, expand } = options;

    const params = {
      '$top': Math.min(top, 100),
      '$skip': skip
    };

    if (filter) params['$filter'] = filter;
    if (expand) params['$expand'] = expand;

    const url = this._buildUrl('Aktør', params);
    return await this._makeRequest(url);
  }

  /**
   * Get voting sessions (Afstemning)
   * 
   * @param {Object} options - Query options
   * @returns {Promise&lt;Object&gt;} API response with voting session data
   */
  async getVotingSessions(options = {}) {
    const { top = 100, skip = 0, filter, expand, select } = options;

    const params = {
      '$top': Math.min(top, 100),
      '$skip': skip
    };

    if (filter) params['$filter'] = filter;
    if (expand) params['$expand'] = expand;
    if (select) params['$select'] = select;

    const url = this._buildUrl('Afstemning', params);
    return await this._makeRequest(url);
  }

  /**
   * Get all voting records for a specific politician
   * 
   * @param {string} politicianName - Full name of politician
   * @param {number} limit - Maximum number of votes to return
   * @returns {Promise&lt;Array&gt;} Array of voting records
   * 
   * @example
   * const votes = await api.getVotingRecords(&quot;Frank Aaen&quot;);
   */
  async getVotingRecords(politicianName, limit = 1000) {
    const allVotes = [];
    let skip = 0;
    const batchSize = 100;

    while (allVotes.length &lt; limit &amp;&amp; skip &lt; 10000) { // Safety limit
      const params = {
        '$expand': 'Afstemning,Aktør',
        '$filter': `Aktør/navn eq '${politicianName}'`,
        '$top': batchSize,
        '$skip': skip
      };

      const url = this._buildUrl('Stemme', params);
      const response = await this._makeRequest(url);
      const votes = response.value || [];

      if (votes.length === 0) {
        break;
      }

      allVotes.push(...votes);
      skip += batchSize;
    }

    return allVotes.slice(0, limit);
  }

  /**
   * Get recent changes to parliamentary data
   * 
   * @param {string} entity - Entity to check ('Sag', 'Aktør', 'Afstemning', etc.)
   * @param {number} hoursBack - How many hours back to check
   * @returns {Promise&lt;Object&gt;} Recent changes in the specified entity
   * 
   * @example
   * // Check for cases updated in last 4 hours
   * const recent = await api.getRecentChanges('Sag', 4);
   */
  async getRecentChanges(entity = 'Sag', hoursBack = 24) {
    const cutoffTime = new Date();
    cutoffTime.setHours(cutoffTime.getHours() - hoursBack);
    const isoTime = cutoffTime.toISOString().slice(0, 19); // Remove milliseconds

    const params = {
      '$filter': `opdateringsdato gt datetime'${isoTime}'`,
      '$orderby': 'opdateringsdato desc',
      '$top': 100
    };

    const url = this._buildUrl(entity, params);
    return await this._makeRequest(url);
  }

  /**
   * Get detailed information about a voting session
   * 
   * @param {number} votingId - ID of the voting session (Afstemning)
   * @param {boolean} expandVotes - Whether to include individual vote details
   * @returns {Promise&lt;Object&gt;} Voting session with optional vote details
   */
  async getVotingSessionDetails(votingId, expandVotes = true) {
    const expandParts = ['Møde'];
    if (expandVotes) {
      expandParts.push('Stemme/Aktør');
    }

    const params = {
      '$filter': `id eq ${votingId}`,
      '$expand': expandParts.join(',')
    };

    const url = this._buildUrl('Afstemning', params);
    const response = await this._makeRequest(url);

    if (response.value &amp;&amp; response.value.length &gt; 0) {
      return response.value[0];
    } else {
      throw new RecordNotFoundError(`Voting session ${votingId} not found`);
    }
  }

  /**
   * Search parliamentary documents by title
   * 
   * @param {string} searchTerm - Term to search for in document titles
   * @param {boolean} includeFiles - Whether to include file download URLs
   * @returns {Promise&lt;Object&gt;} Matching documents
   */
  async searchDocuments(searchTerm, includeFiles = false) {
    const params = {
      '$filter': `substringof('${searchTerm}', titel)`,
      '$top': 100
    };

    if (includeFiles) {
      params['$expand'] = 'Fil';
    }

    const url = this._buildUrl('Dokument', params);
    return await this._makeRequest(url);
  }

  /**
   * Get total count of records in an entity
   * 
   * @param {string} entity - Entity name
   * @returns {Promise&lt;number&gt;} Total number of records
   */
  async getEntityCount(entity) {
    const params = {
      '$inlinecount': 'allpages',
      '$top': 1
    };

    const url = this._buildUrl(entity, params);
    const response = await this._makeRequest(url);

    const countStr = response['odata.count'] || '0';
    return parseInt(countStr, 10);
  }

  /**
   * Generic request method for custom queries
   * 
   * @param {string} entity - Entity name
   * @param {Object} params - OData parameters
   * @returns {Promise&lt;Object&gt;} API response
   */
  async request(entity, params = {}) {
    const url = this._buildUrl(entity, params);
    return await this._makeRequest(url);
  }

  /**
   * Async generator for paginating through all records
   * 
   * @param {string} entity - Entity name
   * @param {Object} options - Pagination options
   * @param {number} options.batchSize - Records per batch (max 100)
   * @param {number} options.maxRecords - Maximum total records to fetch
   * @param {Object} options.params - Additional OData parameters
   * 
   * @example
   * // Process all climate cases
   * for await (const case of api.paginateAll('Sag', {
   *   params: { '$filter': &quot;substringof('klima', titel)&quot; },
   *   maxRecords: 500
   * })) {
   *   console.log(case.titel);
   * }
   */
  async* paginateAll(entity, options = {}) {
    const { batchSize = 100, maxRecords = Infinity, params = {} } = options;

    let skip = 0;
    let totalYielded = 0;
    const safeBatchSize = Math.min(batchSize, 100);

    while (totalYielded &lt; maxRecords &amp;&amp; skip &lt; 100000) { // Safety limit
      const requestParams = {
        ...params,
        '$top': safeBatchSize,
        '$skip': skip
      };

      try {
        const url = this._buildUrl(entity, requestParams);
        const response = await this._makeRequest(url);
        const records = response.value || [];

        if (records.length === 0) {
          break; // No more records
        }

        // Yield each record individually
        for (const record of records) {
          if (totalYielded &gt;= maxRecords) {
            return;
          }
          yield record;
          totalYielded++;
        }

        skip += safeBatchSize;

      } catch (error) {
        console.error(`Error paginating ${entity} at skip=${skip}:`, error);
        break;
      }
    }
  }

  /**
   * Batch multiple requests concurrently
   * 
   * @param {Array} requests - Array of request configurations
   * @param {number} maxConcurrent - Maximum concurrent requests
   * @returns {Promise&lt;Array&gt;} Array of responses
   * 
   * @example
   * const results = await api.batchRequests([
   *   { entity: 'Sag', params: { '$top': 10 } },
   *   { entity: 'Aktør', params: { '$top': 5 } },
   *   { entity: 'Afstemning', params: { '$top': 3 } }
   * ]);
   */
  async batchRequests(requests, maxConcurrent = 5) {
    // Limit concurrent requests to be respectful to the API
    const semaphore = new Semaphore(maxConcurrent);

    const executeRequest = async (request) =&gt; {
      await semaphore.acquire();
      try {
        const url = this._buildUrl(request.entity, request.params || {});
        return await this._makeRequest(url);
      } finally {
        semaphore.release();
      }
    };

    return await Promise.all(requests.map(executeRequest));
  }

  /**
   * Analyze voting patterns for a set of votes
   * 
   * @param {Array} votes - Array of voting records
   * @returns {Object} Voting analysis
   */
  analyzeVotingPatterns(votes) {
    const analysis = {
      totalVotes: votes.length,
      voteTypes: {},
      partiesVotedWith: {},
      timeSpan: { earliest: null, latest: null }
    };

    for (const vote of votes) {
      // Count vote types
      const voteType = vote.typeid;
      analysis.voteTypes[voteType] = (analysis.voteTypes[voteType] || 0) + 1;

      // Track time span
      const voteDate = new Date(vote.Afstemning?.dato || '1900-01-01');
      if (!analysis.timeSpan.earliest || voteDate &lt; analysis.timeSpan.earliest) {
        analysis.timeSpan.earliest = voteDate;
      }
      if (!analysis.timeSpan.latest || voteDate &gt; analysis.timeSpan.latest) {
        analysis.timeSpan.latest = voteDate;
      }
    }

    return analysis;
  }
}

// Helper class for limiting concurrent requests
class Semaphore {
  constructor(max) {
    this.max = max;
    this.current = 0;
    this.queue = [];
  }

  async acquire() {
    return new Promise((resolve) =&gt; {
      if (this.current &lt; this.max) {
        this.current++;
        resolve();
      } else {
        this.queue.push(resolve);
      }
    });
  }

  release() {
    this.current--;
    if (this.queue.length &gt; 0) {
      this.current++;
      const resolve = this.queue.shift();
      resolve();
    }
  }
}

// Custom Error Classes
class APIError extends Error {
  constructor(message, code = 'API_ERROR') {
    super(message);
    this.name = 'APIError';
    this.code = code;
  }
}

class NetworkError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NetworkError';
  }
}

class EntityNotFoundError extends APIError {
  constructor(message) {
    super(message, 'ENTITY_NOT_FOUND');
    this.name = 'EntityNotFoundError';
  }
}

class RecordNotFoundError extends APIError {
  constructor(message) {
    super(message, 'RECORD_NOT_FOUND');
    this.name = 'RecordNotFoundError';
  }
}

class UnsupportedOperationError extends APIError {
  constructor(message) {
    super(message, 'UNSUPPORTED_OPERATION');
    this.name = 'UnsupportedOperationError';
  }
}

// Export for ES6 modules
export {
  DanishParliamentAPI,
  APIError,
  NetworkError,
  EntityNotFoundError,
  RecordNotFoundError,
  UnsupportedOperationError
};

// Export for CommonJS (Node.js)
if (typeof module !== 'undefined' &amp;&amp; module.exports) {
  module.exports = {
    DanishParliamentAPI,
    APIError,
    NetworkError,
    EntityNotFoundError,
    RecordNotFoundError,
    UnsupportedOperationError
  };
}

// Usage Examples
if (typeof window === 'undefined') { // Node.js environment
  // Example usage
  (async () =&gt; {
    try {
      const api = new DanishParliamentAPI();

      // Get recent cases
      console.log('Getting recent cases...');
      const cases = await api.getCases({ top: 5 });
      console.log(`Found ${cases.value.length} cases`);

      // Search for climate legislation
      console.log('\nSearching for climate legislation...');
      const climateCases = await api.getCases({
        filter: &quot;substringof('klima', titel)&quot;,
        top: 10
      });
      console.log(`Found ${climateCases.value.length} climate-related cases`);

      // Get total case count
      console.log('\nGetting total case count...');
      const totalCases = await api.getEntityCount('Sag');
      console.log(`Total cases in database: ${totalCases.toLocaleString()}`);

      // Get recent changes
      console.log('\nChecking recent changes...');
      const recent = await api.getRecentChanges('Sag', 24);
      console.log(`Cases updated in last 24 hours: ${recent.value.length}`);

    } catch (error) {
      if (error instanceof APIError) {
        console.error('API Error:', error.message);
      } else if (error instanceof NetworkError) {
        console.error('Network Error:', error.message);
      } else {
        console.error('Unexpected error:', error);
      }
    }
  })();
}
</code></pre>
<h2 id="key-features">Key Features</h2>
<h3 id="1-modern-javascript">1. Modern JavaScript</h3>
<ul>
<li>Uses native <code>fetch()</code> API (no dependencies)</li>
<li>Async/await throughout for clean code</li>
<li>ES6 classes with proper encapsulation</li>
<li>Comprehensive JSDoc documentation</li>
</ul>
<h3 id="2-error-handling">2. Error Handling</h3>
<ul>
<li>Custom error classes for different failure types</li>
<li>Automatic retry with exponential backoff</li>
<li>Timeout handling with AbortController</li>
<li>Graceful degradation for network issues</li>
</ul>
<h3 id="3-performance-optimizations">3. Performance Optimizations</h3>
<ul>
<li>Built-in rate limiting to respect API</li>
<li>Connection reuse through fetch API</li>
<li>Efficient pagination with generators</li>
<li>Concurrent request batching with limits</li>
</ul>
<h3 id="4-production-ready">4. Production Ready</h3>
<ul>
<li>TypeScript-compatible (JSDoc types)</li>
<li>Works in both browser and Node.js</li>
<li>Comprehensive test coverage potential</li>
<li>Configurable timeout and retry settings</li>
</ul>
<h2 id="installation-setup">Installation &amp; Setup</h2>
<h3 id="browser-usage">Browser Usage</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Danish Parliament API Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type=&quot;module&quot;&gt;
    import { DanishParliamentAPI } from './danish-parliament-api.js';

    const api = new DanishParliamentAPI();

    // Your code here
    api.getCases({ top: 10 }).then(cases =&gt; {
      console.log('Cases:', cases.value);
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="nodejs-usage">Node.js Usage</h3>
<pre><code class="language-javascript">// For Node.js 18+
const { DanishParliamentAPI } = require('./danish-parliament-api.js');

// For older Node.js versions, install node-fetch first:
// npm install node-fetch
// Then uncomment the import at the top of the file

const api = new DanishParliamentAPI({
  timeout: 60000,        // 60 seconds
  retryAttempts: 5,      // 5 retry attempts
  requestDelay: 200      // 200ms between requests
});

async function main() {
  try {
    const cases = await api.getCases({ top: 100 });
    console.log(`Found ${cases.value.length} cases`);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

main();
</code></pre>
<p>This implementation provides a robust, production-ready JavaScript client that handles all the complexities of the Danish Parliament API while providing a clean, modern interface.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
