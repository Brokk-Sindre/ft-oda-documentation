<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Python Error Handling - Test</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">Test</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#python-error-handling" class="nav-link">Python Error Handling</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#overview" class="nav-link">Overview</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#error-classification" class="nav-link">Error Classification</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#production-error-handling-patterns" class="nav-link">Production Error Handling Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#error-recovery-strategies" class="nav-link">Error Recovery Strategies</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="python-error-handling">Python Error Handling</h1>
<p>Comprehensive error handling patterns for the Danish Parliament API, based on real-world testing of all failure modes.</p>
<h2 id="overview">Overview</h2>
<p>The Danish Parliament API has specific error behaviors that require careful handling:</p>
<ul>
<li><strong>HTTP 400</strong>: Invalid OData syntax (returns empty response)</li>
<li><strong>HTTP 404</strong>: Invalid entity names (returns HTML) or missing records (empty response)  </li>
<li><strong>HTTP 501</strong>: Unsupported write operations (returns JSON error)</li>
<li><strong>Silent failures</strong>: Invalid filter fields return all data instead of errors</li>
<li><strong>Network timeouts</strong>: Large queries may timeout</li>
</ul>
<h2 id="error-classification">Error Classification</h2>
<h3 id="1-odata-syntax-errors-http-400">1. OData Syntax Errors (HTTP 400)</h3>
<p>Invalid OData parameters return HTTP 400 with empty response:</p>
<pre><code class="language-python">from danish_parliament_api import DanishParliamentAPI, APIError

def handle_odata_errors():
    &quot;&quot;&quot;Demonstrate OData error handling.&quot;&quot;&quot;
    api = DanishParliamentAPI()

    try:
        # This will fail - invalid expansion
        response = api._make_request(
            api._build_url('Sag', **{'$expand': 'NonExistentRelation'})
        )
    except APIError as e:
        print(f&quot;OData Error: {e}&quot;)
        # Error: Invalid query parameters. Check $expand and $filter syntax.

# Common OData errors:
odata_errors = [
    &quot;Sag?$expand=InvalidRelation&quot;,           # Invalid relationship
    &quot;Sag?$expand=Deep/Very/Deep/Relation&quot;,   # Too deep (&gt;2 levels)
    &quot;Sag?$filter=invalid syntax&quot;,            # Malformed filter
    &quot;Sag?$orderby=nonexistent_field&quot;,        # Invalid field in orderby
]

for error_query in odata_errors:
    try:
        url = f&quot;https://oda.ft.dk/api/{error_query}&quot;
        response = api._make_request(url)
    except APIError as e:
        print(f&quot;Expected error for '{error_query}': {e}&quot;)
</code></pre>
<h3 id="2-entity-not-found-http-404">2. Entity Not Found (HTTP 404)</h3>
<p>Invalid entity names return HTML error pages:</p>
<pre><code class="language-python">def handle_entity_errors():
    &quot;&quot;&quot;Handle invalid entity names.&quot;&quot;&quot;
    api = DanishParliamentAPI()

    try:
        # Invalid entity name
        url = api._build_url('InvalidEntity')
        response = api._make_request(url)
    except EntityNotFoundError as e:
        print(f&quot;Entity Error: {e}&quot;)
        # Suggests checking entity name against metadata

# Test multiple invalid entities
invalid_entities = [
    'Cases',        # English instead of Danish 'Sag'
    'Politicians',  # English instead of Danish 'Akt√∏r'  
    'Votes',        # English instead of Danish 'Stemme'
    'NonExistent',  # Completely invalid
]

for entity in invalid_entities:
    try:
        response = api._make_request(f&quot;https://oda.ft.dk/api/{entity}&quot;)
    except EntityNotFoundError as e:
        print(f&quot;Entity '{entity}' not found: {e}&quot;)
</code></pre>
<h3 id="3-record-not-found-http-404">3. Record Not Found (HTTP 404)</h3>
<p>Valid entities with invalid IDs return empty responses:</p>
<pre><code class="language-python">def handle_record_errors():
    &quot;&quot;&quot;Handle missing record IDs.&quot;&quot;&quot; 
    api = DanishParliamentAPI()

    # Test various invalid IDs
    invalid_ids = [999999999, -1, 0, 'invalid']

    for invalid_id in invalid_ids:
        try:
            url = f&quot;https://oda.ft.dk/api/Sag({invalid_id})&quot;
            response = api._make_request(url)
            print(f&quot;Unexpected: ID {invalid_id} returned data&quot;)
        except RecordNotFoundError as e:
            print(f&quot;Record {invalid_id} not found (expected): {e}&quot;)
        except APIError as e:
            print(f&quot;API error for ID {invalid_id}: {e}&quot;)

# Robust record fetching with fallback
def get_case_safe(api, case_id, fallback_search=True):
    &quot;&quot;&quot;
    Safely get a case by ID with fallback options.

    Args:
        api: DanishParliamentAPI instance
        case_id: Case ID to fetch
        fallback_search: Try searching if direct ID fails

    Returns:
        Case data or None if not found
    &quot;&quot;&quot;
    try:
        # Try direct ID access
        url = api._build_url('Sag', **{'$filter': f'id eq {case_id}'})
        response = api._make_request(url)

        if response.get('value'):
            return response['value'][0]

        # ID not found - try fallback if enabled
        if fallback_search:
            print(f&quot;Case {case_id} not found, searching for similar IDs...&quot;)

            # Search for nearby IDs
            for offset in [-1, 1, -2, 2, -5, 5]:
                try_id = case_id + offset
                url = api._build_url('Sag', **{'$filter': f'id eq {try_id}'})
                response = api._make_request(url)

                if response.get('value'):
                    print(f&quot;Found similar case: {try_id}&quot;)
                    return response['value'][0]

        return None

    except APIError as e:
        print(f&quot;Error fetching case {case_id}: {e}&quot;)
        return None

# Usage
api = DanishParliamentAPI()
case = get_case_safe(api, 999999, fallback_search=True)
if case:
    print(f&quot;Found case: {case['titel'][:50]}...&quot;)
else:
    print(&quot;No case found&quot;)
</code></pre>
<h3 id="4-silent-filter-failures">4. Silent Filter Failures</h3>
<p><strong>Critical</strong>: Invalid field names in filters don't return errors - they return all data!</p>
<pre><code class="language-python">def detect_silent_failures():
    &quot;&quot;&quot;Detect when filters are silently ignored.&quot;&quot;&quot;
    api = DanishParliamentAPI()

    # Test with known small dataset first
    valid_response = api.get_cases(
        filter_expr=&quot;id eq 1&quot;,  # Should return 1 record
        top=100
    )
    valid_count = len(valid_response.get('value', []))
    print(f&quot;Valid filter returned {valid_count} records&quot;)

    # Test with invalid field name
    invalid_response = api.get_cases(
        filter_expr=&quot;invalid_field eq 'test'&quot;,  # Should fail but doesn't!
        top=100
    )
    invalid_count = len(invalid_response.get('value', []))
    print(f&quot;Invalid filter returned {invalid_count} records&quot;)

    if invalid_count == 100:  # Got default batch size
        print(&quot;¬†  WARNING: Invalid filter was silently ignored!&quot;)
        print(&quot;    Always validate filter field names!&quot;)

    return valid_count, invalid_count

# Validation function for filter fields
def validate_filter_fields(api, entity_name, filter_expr):
    &quot;&quot;&quot;
    Validate that filter fields exist before running query.

    Args:
        api: API instance
        entity_name: Entity to check
        filter_expr: Filter expression to validate

    Returns:
        True if filter appears valid, False otherwise
    &quot;&quot;&quot;
    # Get sample record to check available fields
    try:
        sample_response = api._make_request(
            api._build_url(entity_name, **{'$top': 1})
        )

        if not sample_response.get('value'):
            print(f&quot;No records found in {entity_name} to validate against&quot;)
            return False

        sample_record = sample_response['value'][0]
        available_fields = set(sample_record.keys())

        # Extract field names from filter (basic parsing)
        import re
        field_matches = re.findall(r'\b([a-zA-Z√¶√∏√•√Ü√ò√Ö_][a-zA-Z√¶√∏√•√Ü√ò√Ö0-9_]*)\s+(?:eq|ne|gt|lt|ge|le|and|or)', filter_expr)

        invalid_fields = []
        for field in field_matches:
            if field not in available_fields and field not in ['and', 'or', 'not']:
                invalid_fields.append(field)

        if invalid_fields:
            print(f&quot;¬†  Invalid fields detected: {invalid_fields}&quot;)
            print(f&quot;   Available fields: {sorted(available_fields)}&quot;)
            return False

        return True

    except Exception as e:
        print(f&quot;Could not validate fields: {e}&quot;)
        return False  # Assume invalid on error

# Safe filtering with validation
def safe_filter_query(api, entity_name, filter_expr, **params):
    &quot;&quot;&quot;
    Execute filter query with validation to prevent silent failures.

    Args:
        api: API instance
        entity_name: Entity name
        filter_expr: Filter expression
        **params: Additional parameters

    Returns:
        Query results or None if validation fails
    &quot;&quot;&quot;
    # Validate filter fields
    if not validate_filter_fields(api, entity_name, filter_expr):
        print(&quot;Filter validation failed - aborting query&quot;)
        return None

    # Execute query
    try:
        params['$filter'] = filter_expr
        url = api._build_url(entity_name, **params)
        return api._make_request(url)
    except APIError as e:
        print(f&quot;Query failed: {e}&quot;)
        return None

# Usage example
api = DanishParliamentAPI()

# This will validate fields before querying
result = safe_filter_query(
    api, 'Sag', 
    &quot;substringof('klima', titel)&quot;,  # Valid filter
    **{'$top': 10}
)

if result:
    print(f&quot;Query succeeded: {len(result['value'])} records&quot;)
else:
    print(&quot;Query failed validation or execution&quot;)
</code></pre>
<h3 id="5-network-error-handling">5. Network Error Handling</h3>
<p>Comprehensive network error handling with retry logic:</p>
<pre><code class="language-python">import time
import requests
from typing import Optional

class RobustAPI(DanishParliamentAPI):
    &quot;&quot;&quot;Extended API client with robust network error handling.&quot;&quot;&quot;

    def __init__(self, timeout=30, retry_attempts=3, backoff_factor=2):
        super().__init__(timeout, retry_attempts)
        self.backoff_factor = backoff_factor
        self.session = requests.Session()  # Reuse connections

    def _make_request_robust(self, url: str, max_retries: Optional[int] = None) -&gt; dict:
        &quot;&quot;&quot;
        Make HTTP request with comprehensive error handling and retry logic.

        Args:
            url: URL to request
            max_retries: Override default retry attempts

        Returns:
            Parsed JSON response

        Raises:
            NetworkError: For persistent network issues
            APIError: For API-specific errors
        &quot;&quot;&quot;
        max_retries = max_retries or self.retry_attempts
        last_exception = None

        for attempt in range(max_retries):
            try:
                self._rate_limit()

                # Make request with session for connection reuse
                response = self.session.get(url, timeout=self.timeout)

                # Handle HTTP status codes
                if response.status_code == 200:
                    try:
                        return response.json()
                    except ValueError as e:
                        raise APIError(f&quot;Invalid JSON response: {e}&quot;)

                elif response.status_code == 400:
                    raise APIError(
                        f&quot;Bad Request (400): Invalid OData syntax. &quot;
                        f&quot;Check $filter, $expand, and other parameters. URL: {url}&quot;
                    )

                elif response.status_code == 404:
                    # Distinguish between entity not found vs record not found
                    if '/api/' in url and url.count('/') == 4:  # Just entity name
                        raise EntityNotFoundError(f&quot;Entity not found: {url.split('/')[-1]}&quot;)
                    else:  # Specific record or invalid ID
                        raise RecordNotFoundError(f&quot;Record not found: {url}&quot;)

                elif response.status_code == 501:
                    raise UnsupportedOperationError(
                        &quot;This API is read-only. Write operations (POST/PUT/DELETE) are not supported.&quot;
                    )

                elif response.status_code == 503:
                    # Service temporarily unavailable - retry with longer delay
                    if attempt &lt; max_retries - 1:
                        wait_time = (self.backoff_factor ** attempt) * 5  # Longer wait for 503
                        print(f&quot;Service unavailable (503). Retrying in {wait_time} seconds...&quot;)
                        time.sleep(wait_time)
                        continue
                    else:
                        raise NetworkError(f&quot;Service unavailable after {max_retries} attempts&quot;)

                else:
                    response.raise_for_status()

            except requests.exceptions.Timeout as e:
                last_exception = e
                if attempt &lt; max_retries - 1:
                    wait_time = (self.backoff_factor ** attempt) * 1
                    print(f&quot;Request timeout. Retrying in {wait_time} seconds... (attempt {attempt + 1}/{max_retries})&quot;)
                    time.sleep(wait_time)
                    continue
                else:
                    raise NetworkError(f&quot;Request timed out after {self.timeout} seconds. Tried {max_retries} times.&quot;)

            except requests.exceptions.ConnectionError as e:
                last_exception = e
                if attempt &lt; max_retries - 1:
                    wait_time = (self.backoff_factor ** attempt) * 2
                    print(f&quot;Connection error. Retrying in {wait_time} seconds... (attempt {attempt + 1}/{max_retries})&quot;)
                    time.sleep(wait_time)
                    continue
                else:
                    raise NetworkError(f&quot;Connection failed after {max_retries} attempts: {str(e)}&quot;)

            except requests.exceptions.HTTPError as e:
                # For other HTTP errors not specifically handled above
                raise APIError(f&quot;HTTP error {e.response.status_code}: {e}&quot;)

            except requests.exceptions.RequestException as e:
                # Catch-all for other request errors
                raise NetworkError(f&quot;Request failed: {str(e)}&quot;)

        # This should not be reached due to the exception handling above
        raise NetworkError(f&quot;Unknown error after {max_retries} attempts. Last exception: {last_exception}&quot;)

    def health_check(self) -&gt; dict:
        &quot;&quot;&quot;
        Perform basic API health check.

        Returns:
            Health status information
        &quot;&quot;&quot;
        health_info = {
            'api_accessible': False,
            'response_time_ms': None,
            'record_count_sample': None,
            'timestamp': datetime.now().isoformat(),
            'errors': []
        }

        try:
            # Test basic connectivity with timing
            start_time = time.time()
            response = self._make_request_robust(
                self._build_url('Sag', **{'$top': 1})
            )
            response_time = (time.time() - start_time) * 1000  # Convert to ms

            health_info.update({
                'api_accessible': True,
                'response_time_ms': round(response_time, 2),
                'record_count_sample': len(response.get('value', []))
            })

            # Test OData functionality
            try:
                count_response = self.get_entity_count('Sag')
                health_info['total_cases'] = count_response
            except Exception as e:
                health_info['errors'].append(f&quot;Count query failed: {e}&quot;)

            # Test filtering
            try:
                filter_response = self._make_request_robust(
                    self._build_url('Sag', **{
                        '$filter': 'id eq 1',
                        '$top': 1
                    })
                )
                health_info['filtering_works'] = len(filter_response.get('value', [])) &gt; 0
            except Exception as e:
                health_info['errors'].append(f&quot;Filter test failed: {e}&quot;)
                health_info['filtering_works'] = False

        except Exception as e:
            health_info['errors'].append(f&quot;Health check failed: {e}&quot;)

        return health_info

# Usage examples
def example_error_handling():
    &quot;&quot;&quot;Demonstrate comprehensive error handling.&quot;&quot;&quot;
    api = RobustAPI(timeout=60, retry_attempts=5)

    # Health check first
    print(&quot;Performing health check...&quot;)
    health = api.health_check()
    print(f&quot;API accessible: {health['api_accessible']}&quot;)
    print(f&quot;Response time: {health['response_time_ms']}ms&quot;)

    if health['errors']:
        print(f&quot;Health check warnings: {health['errors']}&quot;)

    # Test various error conditions
    error_tests = [
        # Valid query
        ('Valid query', lambda: api.get_cases(top=5)),

        # Invalid entity
        ('Invalid entity', lambda: api._make_request_robust('https://oda.ft.dk/api/InvalidEntity')),

        # Invalid OData
        ('Invalid OData', lambda: api._make_request_robust('https://oda.ft.dk/api/Sag?$expand=Invalid')),

        # Very large query (might timeout)
        ('Large query', lambda: api.get_cases(top=100, expand='SagAkt√∏r/Akt√∏r')),
    ]

    for test_name, test_func in error_tests:
        print(f&quot;\n--- Testing: {test_name} ---&quot;)
        try:
            result = test_func()
            if isinstance(result, dict) and 'value' in result:
                print(f&quot; Success: {len(result['value'])} records&quot;)
            else:
                print(f&quot; Success: {result}&quot;)
        except EntityNotFoundError as e:
            print(f&quot;L Entity Error: {e}&quot;)
        except RecordNotFoundError as e:
            print(f&quot;L Record Error: {e}&quot;)
        except APIError as e:
            print(f&quot;L API Error: {e}&quot;)
        except NetworkError as e:
            print(f&quot;L Network Error: {e}&quot;)
        except Exception as e:
            print(f&quot;L Unexpected Error: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    example_error_handling()
</code></pre>
<h2 id="production-error-handling-patterns">Production Error Handling Patterns</h2>
<h3 id="1-circuit-breaker-pattern">1. Circuit Breaker Pattern</h3>
<pre><code class="language-python">import threading
from datetime import datetime, timedelta

class CircuitBreaker:
    &quot;&quot;&quot;Implement circuit breaker pattern for API reliability.&quot;&quot;&quot;

    def __init__(self, failure_threshold=5, recovery_timeout=60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
        self.lock = threading.Lock()

    def call(self, func, *args, **kwargs):
        &quot;&quot;&quot;Execute function with circuit breaker protection.&quot;&quot;&quot;
        with self.lock:
            if self.state == 'OPEN':
                if self._should_attempt_reset():
                    self.state = 'HALF_OPEN'
                else:
                    raise NetworkError(&quot;Circuit breaker is OPEN - API calls suspended&quot;)

            try:
                result = func(*args, **kwargs)
                self._on_success()
                return result

            except Exception as e:
                self._on_failure()
                raise

    def _should_attempt_reset(self):
        return (datetime.now() - self.last_failure_time).seconds &gt;= self.recovery_timeout

    def _on_success(self):
        self.failure_count = 0
        self.state = 'CLOSED'

    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = datetime.now()

        if self.failure_count &gt;= self.failure_threshold:
            self.state = 'OPEN'

# Usage with circuit breaker
class ProductionAPI(RobustAPI):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.circuit_breaker = CircuitBreaker()

    def safe_request(self, url):
        &quot;&quot;&quot;Make request with circuit breaker protection.&quot;&quot;&quot;
        return self.circuit_breaker.call(self._make_request_robust, url)
</code></pre>
<h3 id="2-comprehensive-logging">2. Comprehensive Logging</h3>
<pre><code class="language-python">import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('danish_parliament_api.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger('DanishParliamentAPI')

class LoggedAPI(RobustAPI):
    &quot;&quot;&quot;API client with comprehensive logging.&quot;&quot;&quot;

    def _make_request_robust(self, url: str, max_retries: Optional[int] = None) -&gt; dict:
        &quot;&quot;&quot;Override with logging.&quot;&quot;&quot;
        logger.info(f&quot;Making request to: {url}&quot;)
        start_time = time.time()

        try:
            result = super()._make_request_robust(url, max_retries)
            response_time = (time.time() - start_time) * 1000

            record_count = len(result.get('value', [])) if 'value' in result else 1
            logger.info(f&quot;Request successful: {record_count} records in {response_time:.1f}ms&quot;)

            return result

        except Exception as e:
            response_time = (time.time() - start_time) * 1000
            logger.error(f&quot;Request failed after {response_time:.1f}ms: {e}&quot;)
            raise

# Usage with logging
api = LoggedAPI()
try:
    cases = api.get_cases(top=10)
    logger.info(f&quot;Successfully retrieved {len(cases['value'])} cases&quot;)
except Exception as e:
    logger.error(f&quot;Failed to retrieve cases: {e}&quot;)
</code></pre>
<h2 id="error-recovery-strategies">Error Recovery Strategies</h2>
<h3 id="1-graceful-degradation">1. Graceful Degradation</h3>
<pre><code class="language-python">def get_cases_with_fallback(api, primary_params, fallback_params_list):
    &quot;&quot;&quot;Try multiple query strategies with fallbacks.&quot;&quot;&quot;

    strategies = [primary_params] + fallback_params_list

    for i, params in enumerate(strategies):
        try:
            logger.info(f&quot;Trying strategy {i + 1}: {params}&quot;)
            return api.get_cases(**params)

        except APIError as e:
            logger.warning(f&quot;Strategy {i + 1} failed: {e}&quot;)
            if i == len(strategies) - 1:
                raise e  # Last strategy failed
            continue

# Usage
api = DanishParliamentAPI()
try:
    cases = get_cases_with_fallback(
        api,
        primary_params={'filter_expr': &quot;substringof('klima', titel)&quot;, 'expand': 'Sagskategori'},
        fallback_params_list=[
            {'filter_expr': &quot;substringof('klima', titel)&quot;},  # Remove expansion
            {'top': 50},  # Just get some cases
            {}  # Last resort - default query
        ]
    )
    print(f&quot;Retrieved {len(cases['value'])} cases using fallback strategy&quot;)
except Exception as e:
    print(f&quot;All strategies failed: {e}&quot;)
</code></pre>
<p>This comprehensive error handling system ensures your application can gracefully handle all known failure modes of the Danish Parliament API while providing useful feedback for debugging and monitoring.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
