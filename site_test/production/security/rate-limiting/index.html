<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Rate Limiting and Throttling - Test</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">Test</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#rate-limiting-and-throttling" class="nav-link">Rate Limiting and Throttling</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#server-side-rate-limiting-analysis" class="nav-link">Server-Side Rate Limiting Analysis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#client-side-rate-limiting-implementation" class="nav-link">Client-Side Rate Limiting Implementation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#practical-implementation-examples" class="nav-link">Practical Implementation Examples</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#monitoring-and-analytics" class="nav-link">Monitoring and Analytics</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#rate-limiting-strategies-by-use-case" class="nav-link">Rate Limiting Strategies by Use Case</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#best-practices-summary" class="nav-link">Best Practices Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="rate-limiting-and-throttling">Rate Limiting and Throttling</h1>
<p>The Danish Parliament API has no server-side rate limiting, making it essential to implement responsible client-side throttling. This guide covers best practices for rate limiting, concurrent request management, and respectful API usage patterns.</p>
<h2 id="server-side-rate-limiting-analysis">Server-Side Rate Limiting Analysis</h2>
<h3 id="no-server-side-limits-detected">No Server-Side Limits Detected</h3>
<p>Based on comprehensive testing (Phase 16 investigation), the API shows no evidence of:</p>
<ul>
<li> No request per minute limits</li>
<li> No concurrent connection limits  </li>
<li> No IP-based throttling</li>
<li> No user agent restrictions</li>
<li> No geographic rate limiting</li>
</ul>
<pre><code class="language-bash"># Testing confirmed no rate limits
for i in {1..100}; do
    curl -s &quot;https://oda.ft.dk/api/Sag?\$top=1&quot; &gt; /dev/null
    echo &quot;Request $i completed&quot;
done
# All 100 requests completed successfully with no throttling
</code></pre>
<h3 id="performance-characteristics">Performance Characteristics</h3>
<p>Response times by request size (tested):
- <strong>Small queries</strong> (1-10 records): 85-150ms
- <strong>Medium queries</strong> (100 records): 200-500ms<br />
- <strong>Large queries</strong> (1000+ records): 1-3 seconds
- <strong>Bulk expansion</strong> (2-level): 2-5 seconds</p>
<h2 id="client-side-rate-limiting-implementation">Client-Side Rate Limiting Implementation</h2>
<h3 id="basic-rate-limiter">Basic Rate Limiter</h3>
<pre><code class="language-python">import time
from collections import deque
from datetime import datetime, timedelta
import threading

class RateLimiter:
    def __init__(self, requests_per_second=5, requests_per_minute=100):
        self.requests_per_second = requests_per_second
        self.requests_per_minute = requests_per_minute
        self.second_window = deque()
        self.minute_window = deque()
        self.lock = threading.Lock()

    def acquire(self):
        &quot;&quot;&quot;Acquire permission to make a request&quot;&quot;&quot;
        with self.lock:
            now = datetime.now()

            # Clean up old requests
            self._cleanup_windows(now)

            # Check per-second limit
            if len(self.second_window) &gt;= self.requests_per_second:
                sleep_time = 1.0 - (now - self.second_window[0]).total_seconds()
                if sleep_time &gt; 0:
                    time.sleep(sleep_time)
                    now = datetime.now()
                    self._cleanup_windows(now)

            # Check per-minute limit  
            if len(self.minute_window) &gt;= self.requests_per_minute:
                sleep_time = 60 - (now - self.minute_window[0]).total_seconds()
                if sleep_time &gt; 0:
                    time.sleep(sleep_time)
                    now = datetime.now()
                    self._cleanup_windows(now)

            # Record this request
            self.second_window.append(now)
            self.minute_window.append(now)

    def _cleanup_windows(self, now):
        &quot;&quot;&quot;Remove old requests from sliding windows&quot;&quot;&quot;
        # Remove requests older than 1 second
        while (self.second_window and 
               now - self.second_window[0] &gt; timedelta(seconds=1)):
            self.second_window.popleft()

        # Remove requests older than 1 minute
        while (self.minute_window and 
               now - self.minute_window[0] &gt; timedelta(minutes=1)):
            self.minute_window.popleft()
</code></pre>
<h3 id="advanced-adaptive-rate-limiter">Advanced Adaptive Rate Limiter</h3>
<pre><code class="language-python">import asyncio
from dataclasses import dataclass
from typing import Optional

@dataclass
class RequestMetrics:
    response_time: float
    status_code: int
    response_size: int
    timestamp: datetime

class AdaptiveRateLimiter:
    def __init__(self, initial_rate=3.0, min_rate=0.5, max_rate=10.0):
        self.current_rate = initial_rate  # requests per second
        self.min_rate = min_rate
        self.max_rate = max_rate
        self.recent_metrics = deque(maxlen=100)
        self.last_request = None
        self.lock = asyncio.Lock()

    async def acquire(self):
        &quot;&quot;&quot;Acquire with adaptive rate adjustment&quot;&quot;&quot;
        async with self.lock:
            if self.last_request:
                elapsed = time.time() - self.last_request
                required_interval = 1.0 / self.current_rate

                if elapsed &lt; required_interval:
                    await asyncio.sleep(required_interval - elapsed)

            self.last_request = time.time()

    def update_metrics(self, metrics: RequestMetrics):
        &quot;&quot;&quot;Update rate based on API performance&quot;&quot;&quot;
        self.recent_metrics.append(metrics)

        # Analyze recent performance
        if len(self.recent_metrics) &gt;= 10:
            avg_response_time = sum(m.response_time for m in list(self.recent_metrics)[-10:]) / 10

            # Adapt rate based on response times
            if avg_response_time &lt; 0.2:  # Fast responses - can increase rate
                self.current_rate = min(self.max_rate, self.current_rate * 1.1)
            elif avg_response_time &gt; 1.0:  # Slow responses - decrease rate
                self.current_rate = max(self.min_rate, self.current_rate * 0.8)

            # Check for errors
            recent_errors = sum(1 for m in list(self.recent_metrics)[-10:] if m.status_code &gt;= 400)
            if recent_errors &gt;= 3:
                self.current_rate = max(self.min_rate, self.current_rate * 0.5)
</code></pre>
<h3 id="concurrent-request-manager">Concurrent Request Manager</h3>
<pre><code class="language-python">import asyncio
import aiohttp
from asyncio import Semaphore

class ConcurrentRequestManager:
    def __init__(self, max_concurrent=5, rate_limiter=None):
        self.semaphore = Semaphore(max_concurrent)
        self.rate_limiter = rate_limiter or RateLimiter()
        self.session = None

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def make_request(self, url, params=None):
        &quot;&quot;&quot;Make rate-limited concurrent request&quot;&quot;&quot;
        async with self.semaphore:  # Limit concurrency
            if hasattr(self.rate_limiter, 'acquire'):
                if asyncio.iscoroutinefunction(self.rate_limiter.acquire):
                    await self.rate_limiter.acquire()
                else:
                    self.rate_limiter.acquire()

            start_time = time.time()

            try:
                async with self.session.get(url, params=params) as response:
                    data = await response.json()

                    # Update rate limiter with metrics if supported
                    if hasattr(self.rate_limiter, 'update_metrics'):
                        metrics = RequestMetrics(
                            response_time=time.time() - start_time,
                            status_code=response.status,
                            response_size=len(str(data)),
                            timestamp=datetime.now()
                        )
                        self.rate_limiter.update_metrics(metrics)

                    return data

            except Exception as e:
                # Handle errors and update rate limiter
                if hasattr(self.rate_limiter, 'update_metrics'):
                    metrics = RequestMetrics(
                        response_time=time.time() - start_time,
                        status_code=500,
                        response_size=0,
                        timestamp=datetime.now()
                    )
                    self.rate_limiter.update_metrics(metrics)
                raise
</code></pre>
<h2 id="practical-implementation-examples">Practical Implementation Examples</h2>
<h3 id="simple-respectful-client">Simple Respectful Client</h3>
<pre><code class="language-python">import requests
import time

class RespectfulDanishParliamentClient:
    def __init__(self, requests_per_second=3):
        self.base_url = &quot;https://oda.ft.dk/api&quot;
        self.min_interval = 1.0 / requests_per_second
        self.last_request = None

    def _throttle(self):
        &quot;&quot;&quot;Simple throttling mechanism&quot;&quot;&quot;
        if self.last_request:
            elapsed = time.time() - self.last_request
            if elapsed &lt; self.min_interval:
                time.sleep(self.min_interval - elapsed)
        self.last_request = time.time()

    def get_cases(self, **params):
        &quot;&quot;&quot;Get cases with throttling&quot;&quot;&quot;
        self._throttle()

        response = requests.get(f&quot;{self.base_url}/Sag&quot;, params=params)
        return response.json()

    def get_all_cases_paginated(self, page_size=100):
        &quot;&quot;&quot;Get all cases with respectful pagination&quot;&quot;&quot;
        all_cases = []
        skip = 0

        while True:
            self._throttle()

            response = requests.get(
                f&quot;{self.base_url}/Sag&quot;,
                params={&quot;$top&quot;: page_size, &quot;$skip&quot;: skip}
            )

            data = response.json()
            cases = data.get('value', [])

            if not cases:
                break

            all_cases.extend(cases)
            skip += page_size

            print(f&quot;Retrieved {len(all_cases)} cases so far...&quot;)

        return all_cases
</code></pre>
<h3 id="bulk-data-processing-with-rate-limiting">Bulk Data Processing with Rate Limiting</h3>
<pre><code class="language-python">import asyncio
from typing import List, Dict, Any

class BulkDataProcessor:
    def __init__(self):
        self.rate_limiter = AdaptiveRateLimiter(initial_rate=4.0)
        self.session = None

    async def process_large_dataset(self, entity: str, batch_size: int = 100):
        &quot;&quot;&quot;Process large datasets with rate limiting&quot;&quot;&quot;
        async with aiohttp.ClientSession() as session:
            self.session = session

            # First, get total count
            await self.rate_limiter.acquire()
            async with session.get(
                f&quot;https://oda.ft.dk/api/{entity}&quot;,
                params={&quot;$top&quot;: 1, &quot;$inlinecount&quot;: &quot;allpages&quot;}
            ) as response:
                data = await response.json()
                total_records = int(data.get('odata.count', 0))

            print(f&quot;Processing {total_records} records from {entity}&quot;)

            # Process in batches
            all_data = []
            for skip in range(0, total_records, batch_size):
                batch_data = await self._get_batch(entity, skip, batch_size)
                all_data.extend(batch_data)

                print(f&quot;Processed {len(all_data)}/{total_records} records&quot;)

                # Add extra delay for large batches
                if batch_size &gt; 100:
                    await asyncio.sleep(0.5)

            return all_data

    async def _get_batch(self, entity: str, skip: int, batch_size: int):
        &quot;&quot;&quot;Get a single batch with rate limiting&quot;&quot;&quot;
        await self.rate_limiter.acquire()

        try:
            async with self.session.get(
                f&quot;https://oda.ft.dk/api/{entity}&quot;,
                params={&quot;$top&quot;: batch_size, &quot;$skip&quot;: skip}
            ) as response:
                data = await response.json()
                return data.get('value', [])

        except Exception as e:
            print(f&quot;Error getting batch {skip}-{skip+batch_size}: {e}&quot;)
            return []

# Usage
async def main():
    processor = BulkDataProcessor()
    all_actors = await processor.process_large_dataset('Akt√∏r', batch_size=200)
    print(f&quot;Retrieved {len(all_actors)} actors total&quot;)

# Run the bulk processor
# asyncio.run(main())
</code></pre>
<h3 id="production-ready-rate-limited-client">Production-Ready Rate Limited Client</h3>
<pre><code class="language-python">import logging
from contextlib import contextmanager
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List

@dataclass
class RateLimitConfig:
    requests_per_second: float = 3.0
    requests_per_minute: int = 100
    max_concurrent: int = 5
    backoff_factor: float = 1.5
    max_retries: int = 3

class ProductionRateLimitedClient:
    def __init__(self, config: RateLimitConfig = None):
        self.config = config or RateLimitConfig()
        self.rate_limiter = RateLimiter(
            requests_per_second=self.config.requests_per_second,
            requests_per_minute=self.config.requests_per_minute
        )
        self.base_url = &quot;https://oda.ft.dk/api&quot;
        self.logger = logging.getLogger(__name__)

    def make_request(self, endpoint: str, params: Dict[str, Any] = None) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;Make a rate-limited request with retries&quot;&quot;&quot;
        for attempt in range(self.config.max_retries):
            try:
                self.rate_limiter.acquire()

                response = requests.get(
                    f&quot;{self.base_url}/{endpoint}&quot;,
                    params=params,
                    timeout=30
                )

                if response.status_code == 200:
                    return response.json()
                elif response.status_code == 429:  # Rate limited (though not expected)
                    wait_time = (self.config.backoff_factor ** attempt) * 2
                    self.logger.warning(f&quot;Rate limited, waiting {wait_time}s&quot;)
                    time.sleep(wait_time)
                    continue
                else:
                    response.raise_for_status()

            except requests.exceptions.RequestException as e:
                if attempt == self.config.max_retries - 1:
                    self.logger.error(f&quot;Request failed after {self.config.max_retries} attempts: {e}&quot;)
                    raise

                wait_time = (self.config.backoff_factor ** attempt)
                self.logger.warning(f&quot;Request failed (attempt {attempt + 1}), retrying in {wait_time}s: {e}&quot;)
                time.sleep(wait_time)

        raise Exception(&quot;Max retries exceeded&quot;)

    @contextmanager
    def bulk_operation(self, reduced_rate=True):
        &quot;&quot;&quot;Context manager for bulk operations with reduced rate&quot;&quot;&quot;
        if reduced_rate:
            original_rate = self.rate_limiter.requests_per_second
            self.rate_limiter.requests_per_second = max(1.0, original_rate * 0.5)

        try:
            yield self
        finally:
            if reduced_rate:
                self.rate_limiter.requests_per_second = original_rate

    def get_paginated_data(self, entity: str, page_size: int = 100, 
                          max_records: Optional[int] = None) -&gt; List[Dict[str, Any]]:
        &quot;&quot;&quot;Get paginated data with rate limiting&quot;&quot;&quot;
        all_data = []
        skip = 0

        with self.bulk_operation():
            while True:
                if max_records and len(all_data) &gt;= max_records:
                    break

                current_page_size = min(page_size, (max_records - len(all_data)) if max_records else page_size)

                data = self.make_request(entity, {
                    &quot;$top&quot;: current_page_size,
                    &quot;$skip&quot;: skip
                })

                records = data.get('value', [])
                if not records:
                    break

                all_data.extend(records)
                skip += len(records)

                self.logger.info(f&quot;Retrieved {len(all_data)} records from {entity}&quot;)

                if len(records) &lt; current_page_size:
                    break

        return all_data
</code></pre>
<h2 id="monitoring-and-analytics">Monitoring and Analytics</h2>
<h3 id="request-metrics-collection">Request Metrics Collection</h3>
<pre><code class="language-python">import csv
from collections import defaultdict
from dataclasses import asdict

class RateLimitingMetrics:
    def __init__(self):
        self.request_history = []
        self.endpoint_stats = defaultdict(list)

    def record_request(self, endpoint: str, metrics: RequestMetrics):
        &quot;&quot;&quot;Record request metrics&quot;&quot;&quot;
        self.request_history.append(metrics)
        self.endpoint_stats[endpoint].append(metrics)

    def get_performance_summary(self) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;Get performance summary&quot;&quot;&quot;
        if not self.request_history:
            return {}

        response_times = [m.response_time for m in self.request_history]
        response_sizes = [m.response_size for m in self.request_history]

        return {
            'total_requests': len(self.request_history),
            'avg_response_time': sum(response_times) / len(response_times),
            'min_response_time': min(response_times),
            'max_response_time': max(response_times),
            'avg_response_size': sum(response_sizes) / len(response_sizes),
            'error_count': sum(1 for m in self.request_history if m.status_code &gt;= 400),
            'success_rate': sum(1 for m in self.request_history if m.status_code &lt; 400) / len(self.request_history)
        }

    def export_metrics(self, filename: str):
        &quot;&quot;&quot;Export metrics to CSV&quot;&quot;&quot;
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = ['timestamp', 'response_time', 'status_code', 'response_size']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            writer.writeheader()
            for metrics in self.request_history:
                writer.writerow(asdict(metrics))
</code></pre>
<h2 id="rate-limiting-strategies-by-use-case">Rate Limiting Strategies by Use Case</h2>
<h3 id="research-and-analysis">Research and Analysis</h3>
<pre><code class="language-python"># Conservative rate for research applications
research_client = ProductionRateLimitedClient(
    RateLimitConfig(
        requests_per_second=2.0,
        requests_per_minute=60,
        max_concurrent=3
    )
)
</code></pre>
<h3 id="real-time-monitoring">Real-time Monitoring</h3>
<pre><code class="language-python"># More aggressive rate for real-time applications
monitoring_client = ProductionRateLimitedClient(
    RateLimitConfig(
        requests_per_second=5.0,
        requests_per_minute=200,
        max_concurrent=8
    )
)
</code></pre>
<h3 id="bulk-data-processing">Bulk Data Processing</h3>
<pre><code class="language-python"># Reduced rate for bulk processing
bulk_client = ProductionRateLimitedClient(
    RateLimitConfig(
        requests_per_second=1.5,
        requests_per_minute=50,
        max_concurrent=2
    )
)
</code></pre>
<h2 id="best-practices-summary">Best Practices Summary</h2>
<h3 id="rate-limiting-guidelines">Rate Limiting Guidelines</h3>
<ol>
<li><strong>Start Conservative</strong>: Begin with 2-3 requests per second</li>
<li><strong>Monitor Performance</strong>: Track response times and adjust accordingly</li>
<li><strong>Implement Backoff</strong>: Use exponential backoff for retries</li>
<li><strong>Respect Infrastructure</strong>: Consider server load during peak hours</li>
<li><strong>Batch When Possible</strong>: Group related requests using <code>$expand</code></li>
<li><strong>Cache Responses</strong>: Implement caching to reduce API calls</li>
</ol>
<h3 id="ethical-considerations">Ethical Considerations</h3>
<pre><code class="language-python">class EthicalAPIClient:
    def __init__(self):
        self.daily_request_count = 0
        self.max_daily_requests = 10000  # Self-imposed limit

    def make_request(self, *args, **kwargs):
        if self.daily_request_count &gt;= self.max_daily_requests:
            raise Exception(&quot;Daily request limit reached - being respectful to public infrastructure&quot;)

        self.daily_request_count += 1
        return super().make_request(*args, **kwargs)
</code></pre>
<h3 id="production-checklist">Production Checklist</h3>
<ul>
<li>[ ] <strong>Rate Limiting Implemented</strong>: Client-side throttling configured</li>
<li>[ ] <strong>Concurrent Limits</strong>: Maximum concurrent requests set</li>
<li>[ ] <strong>Error Handling</strong>: Proper retry logic with backoff</li>
<li>[ ] <strong>Metrics Collection</strong>: Request performance monitoring</li>
<li>[ ] <strong>Adaptive Behavior</strong>: Rate adjustment based on performance</li>
<li>[ ] <strong>Resource Limits</strong>: Daily/hourly usage caps</li>
<li>[ ] <strong>Logging</strong>: Request patterns and errors logged</li>
<li>[ ] <strong>Testing</strong>: Rate limiting tested under load</li>
</ul>
<p>The Danish Parliament API's lack of server-side rate limiting places responsibility on clients to implement respectful usage patterns. Proper rate limiting ensures sustainable access to this valuable public resource while maintaining good performance for all users.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
