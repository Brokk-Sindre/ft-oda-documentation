<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Pagination Documentation - Test</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">Test</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#pagination-documentation" class="nav-link">Pagination Documentation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-pagination-parameters" class="nav-link">Core Pagination Parameters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#real-dataset-examples" class="nav-link">Real Dataset Examples</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#efficient-pagination-patterns" class="nav-link">Efficient Pagination Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#performance-characteristics" class="nav-link">Performance Characteristics</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#real-time-data-access-patterns" class="nav-link">Real-Time Data Access Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#advanced-pagination-techniques" class="nav-link">Advanced Pagination Techniques</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#error-handling-in-pagination" class="nav-link">Error Handling in Pagination</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#best-practices-summary" class="nav-link">Best Practices Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pagination-patterns-reference" class="nav-link">Common Pagination Patterns Reference</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="pagination-documentation">Pagination Documentation</h1>
<p>The Danish Parliament API implements efficient pagination with a <strong>hard limit of 100 records per request</strong>. This guide covers all pagination strategies, performance characteristics, and best practices for accessing large datasets.</p>
<h2 id="core-pagination-parameters">Core Pagination Parameters</h2>
<h3 id="top-parameter-record-limit">$top Parameter - Record Limit</h3>
<p>The <code>$top</code> parameter limits the number of records returned:</p>
<table>
<thead>
<tr>
<th><code>$top</code> Value</th>
<th>Records Returned</th>
<th>Response Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1-50</code></td>
<td>Exact count</td>
<td>~85ms</td>
</tr>
<tr>
<td><code>51-100</code></td>
<td>Exact count</td>
<td>~90ms</td>
</tr>
<tr>
<td><code>101+</code></td>
<td><strong>100 (capped)</strong></td>
<td>~90ms</td>
</tr>
</tbody>
</table>
<p>!!! danger "Hard Limit: 100 Records Maximum"
    <strong>Any <code>$top</code> value greater than 100 returns exactly 100 records</strong>. This is a hard server-side limit that cannot be bypassed.</p>
<pre><code>```bash
# These all return 100 records:
curl "https://oda.ft.dk/api/Sag?%24top=101"    # Returns 100
curl "https://oda.ft.dk/api/Sag?%24top=1000"   # Returns 100  
curl "https://oda.ft.dk/api/Sag?%24top=10000"  # Returns 100
```
</code></pre>
<h3 id="skip-parameter-offset-control">$skip Parameter - Offset Control</h3>
<p>The <code>$skip</code> parameter skips a specified number of records:</p>
<pre><code class="language-bash"># Basic pagination pattern
curl &quot;https://oda.ft.dk/api/Sag?%24skip=0&amp;%24top=100&quot;    # Records 1-100
curl &quot;https://oda.ft.dk/api/Sag?%24skip=100&amp;%24top=100&quot;  # Records 101-200  
curl &quot;https://oda.ft.dk/api/Sag?%24skip=200&amp;%24top=100&quot;  # Records 201-300
</code></pre>
<h3 id="inlinecount-parameter-total-count">$inlinecount Parameter - Total Count</h3>
<p>Get the total number of records matching your query:</p>
<pre><code class="language-bash"># Include total count in response
curl &quot;https://oda.ft.dk/api/Sag?%24inlinecount=allpages&amp;%24top=10&quot;
</code></pre>
<p>Response includes total count:</p>
<pre><code class="language-json">{
  &quot;odata.count&quot;: &quot;96538&quot;,
  &quot;value&quot;: [
    // 10 records
  ]
}
</code></pre>
<h2 id="real-dataset-examples">Real Dataset Examples</h2>
<h3 id="sag-cases-96538-records">Sag (Cases) - 96,538+ Records</h3>
<p><strong>Challenge</strong>: Access all parliamentary cases efficiently</p>
<pre><code class="language-bash"># Get total case count
curl &quot;https://oda.ft.dk/api/Sag?%24inlinecount=allpages&amp;%24top=1&quot; | jq '.[&quot;odata.count&quot;]'
# Result: &quot;96538&quot;

# Calculate pages needed: 96,538 ÷ 100 = 966 pages
# Pages: 0, 100, 200, 300... 96,500
</code></pre>
<p><strong>Complete Access Strategy</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
# Access all 96,538 cases efficiently
for skip in {0..96500..100}; do
    echo &quot;Fetching records $((skip+1)) to $((skip+100))&quot;
    curl -s &quot;https://oda.ft.dk/api/Sag?%24skip=$skip&amp;%24top=100&quot; | jq '.value'
    sleep 0.1  # Rate limiting
done
</code></pre>
<h3 id="aktr-actors-18139-records">Aktør (Actors) - 18,139+ Records</h3>
<p><strong>182 pages of actors (politicians, committees, ministries)</strong>:</p>
<pre><code class="language-bash"># Calculate pagination for actors
total_actors=18139
pages=$(( (total_actors + 99) / 100 ))  # Ceiling division = 182 pages

for page in $(seq 0 $((pages-1))); do
    skip=$((page * 100))
    curl -s &quot;https://oda.ft.dk/api/Aktør?%24skip=$skip&amp;%24top=100&quot;
done
</code></pre>
<h3 id="stemme-votes-millions-of-records">Stemme (Votes) - Millions of Records</h3>
<p><strong>Largest entity - requires strategic filtering</strong>:</p>
<pre><code class="language-bash"># Don't try to get all votes - filter first!
# Get votes for specific voting session
curl &quot;https://oda.ft.dk/api/Stemme?%24filter=afstemningid%20eq%2012345&amp;%24top=100&quot;

# Get votes by specific politician
curl &quot;https://oda.ft.dk/api/Stemme?%24filter=Aktør/navn%20eq%20'Frank%20Aaen'&amp;%24expand=Aktør&amp;%24top=100&quot;
</code></pre>
<h2 id="efficient-pagination-patterns">Efficient Pagination Patterns</h2>
<h3 id="pattern-1-complete-dataset-access">Pattern 1: Complete Dataset Access</h3>
<pre><code class="language-python"># Python: Access complete dataset with pagination
import requests
import time

def get_all_records(entity_name, filter_expr=None):
    &quot;&quot;&quot;Get all records from an entity using pagination&quot;&quot;&quot;
    base_url = &quot;https://oda.ft.dk/api/&quot;
    all_records = []
    skip = 0
    batch_size = 100

    while True:
        # Build URL with pagination
        url = f&quot;{base_url}{entity_name}?$top={batch_size}&amp;$skip={skip}&quot;
        if filter_expr:
            url += f&quot;&amp;$filter={filter_expr}&quot;

        # Make request
        response = requests.get(url)
        data = response.json()

        # Add records to collection
        records = data.get('value', [])
        all_records.extend(records)

        # Check if we've reached the end
        if len(records) &lt; batch_size:
            break

        skip += batch_size
        time.sleep(0.1)  # Rate limiting

    return all_records

# Usage examples
all_cases = get_all_records('Sag')
climate_cases = get_all_records('Sag', &quot;substringof('klima',titel)&quot;)
</code></pre>
<h3 id="pattern-2-streaming-access">Pattern 2: Streaming Access</h3>
<pre><code class="language-javascript">// JavaScript: Stream large datasets
async function* streamRecords(entityName, options = {}) {
    const { batchSize = 100, filter, expand } = options;
    let skip = 0;

    while (true) {
        const params = new URLSearchParams();
        params.append('$top', batchSize);
        params.append('$skip', skip);

        if (filter) params.append('$filter', filter);
        if (expand) params.append('$expand', expand);

        const response = await fetch(`https://oda.ft.dk/api/${entityName}?${params}`);
        const data = await response.json();

        const records = data.value || [];

        // Yield each record
        for (const record of records) {
            yield record;
        }

        // Check if we've reached the end
        if (records.length &lt; batchSize) {
            break;
        }

        skip += batchSize;
        await new Promise(resolve =&gt; setTimeout(resolve, 100)); // Rate limiting
    }
}

// Usage
for await (const case of streamRecords('Sag', { filter: &quot;year(opdateringsdato) eq 2025&quot; })) {
    console.log(case.titel);
}
</code></pre>
<h3 id="pattern-3-parallel-batch-processing">Pattern 3: Parallel Batch Processing</h3>
<pre><code class="language-python"># Python: Parallel processing of known dataset size
import asyncio
import aiohttp
from math import ceil

async def fetch_batch(session, entity, skip, top=100):
    &quot;&quot;&quot;Fetch a single batch of records&quot;&quot;&quot;
    url = f&quot;https://oda.ft.dk/api/{entity}?$skip={skip}&amp;$top={top}&quot;
    async with session.get(url) as response:
        data = await response.json()
        return data.get('value', [])

async def get_all_parallel(entity_name, total_records, batch_size=100, max_concurrent=5):
    &quot;&quot;&quot;Get all records using parallel requests&quot;&quot;&quot;
    total_batches = ceil(total_records / batch_size)

    async with aiohttp.ClientSession() as session:
        semaphore = asyncio.Semaphore(max_concurrent)

        async def fetch_with_semaphore(skip):
            async with semaphore:
                return await fetch_batch(session, entity_name, skip, batch_size)

        # Create tasks for all batches
        tasks = [
            fetch_with_semaphore(skip) 
            for skip in range(0, total_records, batch_size)
        ]

        # Execute all tasks and collect results
        batches = await asyncio.gather(*tasks)

        # Flatten results
        all_records = []
        for batch in batches:
            all_records.extend(batch)

        return all_records

# Usage - Get all 18,139 actors in parallel
actors = await get_all_parallel('Aktør', 18139)
</code></pre>
<h2 id="performance-characteristics">Performance Characteristics</h2>
<h3 id="response-time-analysis-tested">Response Time Analysis (Tested)</h3>
<p>Based on comprehensive testing of the live API:</p>
<table>
<thead>
<tr>
<th>Query Type</th>
<th>Response Time</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$top=1-50</code></td>
<td>~85ms</td>
<td>Optimal for small queries</td>
</tr>
<tr>
<td><code>$top=51-100</code></td>
<td>~90ms</td>
<td>Standard pagination size</td>
</tr>
<tr>
<td><code>$skip=0-1000</code></td>
<td>~90ms</td>
<td>No penalty for small skips</td>
</tr>
<tr>
<td><code>$skip=10000+</code></td>
<td>~90ms</td>
<td>Excellent performance even with large offsets</td>
</tr>
<tr>
<td>Complex filters</td>
<td>+10-20ms</td>
<td>Minimal filter overhead</td>
</tr>
<tr>
<td>Multi-level expansion</td>
<td>~1.8s</td>
<td>Significant overhead for deep relationships</td>
</tr>
</tbody>
</table>
<h3 id="pagination-vs-filtering-performance">Pagination vs. Filtering Performance</h3>
<pre><code class="language-bash"># Fast: Pagination without expansion
time curl -s &quot;https://oda.ft.dk/api/Sag?%24skip=10000&amp;%24top=100&quot; &gt; /dev/null
# Result: ~0.09s

# Medium: Pagination with simple expansion  
time curl -s &quot;https://oda.ft.dk/api/Sag?%24skip=1000&amp;%24top=100&amp;%24expand=Sagskategori&quot; &gt; /dev/null
# Result: ~0.3s

# Slow: Complex multi-level expansion
time curl -s &quot;https://oda.ft.dk/api/Afstemning?%24expand=Stemme/Aktør&amp;%24top=100&quot; &gt; /dev/null  
# Result: ~1.8s
</code></pre>
<h2 id="real-time-data-access-patterns">Real-Time Data Access Patterns</h2>
<h3 id="recent-updates-strategy">Recent Updates Strategy</h3>
<p>Instead of paginating through all data, filter for recent changes:</p>
<pre><code class="language-bash"># Get today's updates (much more efficient than full pagination)  
curl &quot;https://oda.ft.dk/api/Sag?%24filter=opdateringsdato%20gt%20datetime'2025-09-09T00:00:00'&amp;%24orderby=opdateringsdato%20desc&amp;%24top=100&quot;

# Last 24 hours of parliamentary activity
curl &quot;https://oda.ft.dk/api/Sag?%24filter=opdateringsdato%20gt%20datetime'2025-09-08T18:00:00'&amp;%24inlinecount=allpages&amp;%24top=100&quot;
</code></pre>
<h3 id="entity-specific-pagination-strategies">Entity-Specific Pagination Strategies</h3>
<h4 id="large-entities-require-pagination">Large Entities (Require Pagination)</h4>
<pre><code class="language-bash"># Sag (Cases): 96,538 records - Always paginate
curl &quot;https://oda.ft.dk/api/Sag?%24skip=0&amp;%24top=100&quot;

# Aktør (Actors): 18,139 records - 182 pages
curl &quot;https://oda.ft.dk/api/Aktør?%24skip=0&amp;%24top=100&quot;  

# Stemme (Votes): Millions - Filter first, then paginate
curl &quot;https://oda.ft.dk/api/Stemme?%24filter=afstemningid%20eq%2012345&amp;%24skip=0&amp;%24top=100&quot;
</code></pre>
<h4 id="medium-entities-selective-pagination">Medium Entities (Selective Pagination)</h4>
<pre><code class="language-bash"># Dokument: Large but often filtered by type
curl &quot;https://oda.ft.dk/api/Dokument?%24filter=Dokumenttype/type%20eq%20'Lovforslag'&amp;%24skip=0&amp;%24top=100&quot;
</code></pre>
<h4 id="small-entities-rarely-need-pagination">Small Entities (Rarely Need Pagination)</h4>
<pre><code class="language-bash"># Aktørtype: Only ~15 records
curl &quot;https://oda.ft.dk/api/Aktørtype&quot;

# Afstemningstype: Only ~5 voting types  
curl &quot;https://oda.ft.dk/api/Afstemningstype&quot;
</code></pre>
<h2 id="advanced-pagination-techniques">Advanced Pagination Techniques</h2>
<h3 id="count-first-strategy">Count-First Strategy</h3>
<p>Always check total count before beginning large operations:</p>
<pre><code class="language-bash"># Step 1: Get total count
total=$(curl -s &quot;https://oda.ft.dk/api/Sag?%24inlinecount=allpages&amp;%24top=1&quot; | jq -r '.[&quot;odata.count&quot;]')
echo &quot;Total records: $total&quot;

# Step 2: Calculate pages needed  
pages=$(( (total + 99) / 100 ))
echo &quot;Pages required: $pages&quot;

# Step 3: Paginate efficiently
for skip in $(seq 0 100 $((total - 1))); do
    curl -s &quot;https://oda.ft.dk/api/Sag?%24skip=$skip&amp;%24top=100&quot;
done
</code></pre>
<h3 id="filtered-pagination">Filtered Pagination</h3>
<p>Combine filtering with pagination for targeted data access:</p>
<pre><code class="language-bash"># Climate legislation pagination (much smaller dataset)
curl -s &quot;https://oda.ft.dk/api/Sag?%24filter=substringof('klima',titel)&amp;%24inlinecount=allpages&amp;%24top=1&quot;
# Result: {&quot;odata.count&quot;: &quot;89&quot;, &quot;value&quot;: [...]}

# Only 1 page needed for climate cases!
curl &quot;https://oda.ft.dk/api/Sag?%24filter=substringof('klima',titel)&amp;%24top=100&quot;
</code></pre>
<h3 id="year-based-pagination-strategy">Year-Based Pagination Strategy</h3>
<p>For historical analysis, paginate by year to manage large datasets:</p>
<pre><code class="language-python"># Python: Year-by-year access pattern
def get_cases_by_year(year, max_records=None):
    &quot;&quot;&quot;Get all cases for a specific year with optional limit&quot;&quot;&quot;
    filter_expr = f&quot;year(opdateringsdato) eq {year}&quot;

    # Get count for this year
    count_url = f&quot;https://oda.ft.dk/api/Sag?$filter={filter_expr}&amp;$inlinecount=allpages&amp;$top=1&quot;
    response = requests.get(count_url)
    total_count = int(response.json()['odata.count'])

    print(f&quot;Year {year}: {total_count} cases&quot;)

    if max_records:
        total_count = min(total_count, max_records)

    # Paginate through year's data
    records = []
    for skip in range(0, total_count, 100):
        batch_url = f&quot;https://oda.ft.dk/api/Sag?$filter={filter_expr}&amp;$skip={skip}&amp;$top=100&quot;
        batch_response = requests.get(batch_url)
        batch_data = batch_response.json().get('value', [])
        records.extend(batch_data)

        if len(batch_data) &lt; 100:  # End of data
            break

    return records

# Usage: Get all cases from 2025
cases_2025 = get_cases_by_year(2025)
print(f&quot;Retrieved {len(cases_2025)} cases from 2025&quot;)
</code></pre>
<h2 id="error-handling-in-pagination">Error Handling in Pagination</h2>
<h3 id="detection-of-pagination-issues">Detection of Pagination Issues</h3>
<pre><code class="language-python"># Python: Robust pagination error handling
def paginate_safely(entity, batch_size=100, max_retries=3):
    skip = 0
    all_records = []
    consecutive_errors = 0

    while consecutive_errors &lt; max_retries:
        try:
            url = f&quot;https://oda.ft.dk/api/{entity}?$skip={skip}&amp;$top={batch_size}&quot;
            response = requests.get(url, timeout=30)

            if response.status_code != 200:
                print(f&quot;HTTP {response.status_code} at skip={skip}&quot;)
                consecutive_errors += 1
                continue

            data = response.json()
            batch = data.get('value', [])

            if not batch:  # End of data
                print(f&quot;Completed: {len(all_records)} total records&quot;)
                break

            all_records.extend(batch) 
            skip += batch_size
            consecutive_errors = 0  # Reset error counter

            # Progress indicator
            if skip % 1000 == 0:
                print(f&quot;Progress: {len(all_records)} records retrieved&quot;)

        except requests.RequestException as e:
            print(f&quot;Request error at skip={skip}: {e}&quot;)
            consecutive_errors += 1
            time.sleep(2 ** consecutive_errors)  # Exponential backoff

    return all_records
</code></pre>
<h2 id="best-practices-summary">Best Practices Summary</h2>
<ol>
<li><strong>Respect the 100-record limit</strong> - Plan pagination accordingly</li>
<li><strong>Use <code>$inlinecount=allpages</code></strong> to calculate total pages needed  </li>
<li><strong>Filter before paginating</strong> to reduce dataset size</li>
<li><strong>Monitor response times</strong> - Complex expansion can be slow</li>
<li><strong>Implement rate limiting</strong> - Be respectful of the API</li>
<li><strong>Handle errors gracefully</strong> - Network issues can occur</li>
<li><strong>Use parallel processing</strong> cautiously to avoid overwhelming the server</li>
<li><strong>Consider real-time patterns</strong> - Recent updates are more efficient than full dataset access</li>
</ol>
<h2 id="common-pagination-patterns-reference">Common Pagination Patterns Reference</h2>
<h3 id="basic-sequential-pagination">Basic Sequential Pagination</h3>
<pre><code class="language-bash">for skip in {0..1000..100}; do
    curl &quot;https://oda.ft.dk/api/Sag?%24skip=$skip&amp;%24top=100&quot;
done
</code></pre>
<h3 id="filtered-sequential-pagination">Filtered Sequential Pagination</h3>
<pre><code class="language-bash">filter=&quot;year(opdateringsdato)%20eq%202025&quot;
for skip in {0..400..100}; do
    curl &quot;https://oda.ft.dk/api/Sag?%24filter=$filter&amp;%24skip=$skip&amp;%24top=100&quot;
done
</code></pre>
<h3 id="count-first-pagination">Count-First Pagination</h3>
<pre><code class="language-bash"># Get total count
count=$(curl -s &quot;https://oda.ft.dk/api/Sag?%24inlinecount=allpages&amp;%24top=1&quot; | jq -r '.[&quot;odata.count&quot;]')

# Paginate based on actual count
for skip in $(seq 0 100 $((count - 1))); do
    curl &quot;https://oda.ft.dk/api/Sag?%24skip=$skip&amp;%24top=100&quot;
done
</code></pre>
<p>The Danish Parliament API's pagination system is highly efficient and reliable. With the 100-record limit and strategic pagination patterns, you can access the complete 74+ year archive of Danish democratic data effectively.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
